\documentclass[]{rptuseminar}

% Specify that the source file has UTF8 encoding
\usepackage[utf8]{inputenc}
% Set up the document font; font encoding (here T1) has to fit the used font.
\usepackage[T1]{fontenc}
\usepackage{lmodern}

% Load language spec
\usepackage[american]{babel}
% German article --> ngerman (n for »neue deutsche Rechtschreibung«)
% British English --> english

% Ffor bibliography and \cite
\usepackage{cite}

% AMS extensions for math typesetting
\usepackage[intlimits]{mathtools}
\usepackage{amssymb}
% ... there are many more ...


% Load \todo command for notes
\usepackage{todonotes}
% Sebastian's favorite command for large inline todonotes
% Caveat: does not work well with \listoftodos
\newcommand\todoin[2][]{\todo[inline, caption={2do}, #1]{
		\begin{minipage}{\linewidth-1em}\noindent\relax#2\end{minipage}}}

% Load \includegraphics command for including pictures (pdf or png highly recommended)
\usepackage{graphicx}

% Typeset source/pseudo code
\usepackage{listings}

% Load TikZ library for creating graphics
% Using the PGF/TikZ manual and/or tex.stackexchange.com is highly adviced.
\usepackage{tikz}
% Load tikz libraries needed below (see the manual for a full list)
\usetikzlibrary{automata,positioning}

% Load \url command for easier hyperlinks without special link text
\usepackage{url}

% Load support for links in pdfs
\usepackage{hyperref}
\setlength{\footnotesep}{10pt}

% Defines default styling for code listings
\definecolor{gray_ulisses}{gray}{0.55}
\definecolor{green_ulises}{rgb}{0.2,0.75,0}
\lstset{%
  columns=flexible,
  keepspaces=true,
  tabsize=2,
  basicstyle={\fontfamily{tx}\ttfamily\small},
  stringstyle=\color{green_ulises},
  commentstyle=\color{gray_ulisses},
  identifierstyle=\slshape{},
  keywordstyle=\bfseries,
  numberstyle=\small\color{gray_ulisses},
  backgroundcolor=\color{gray!5},
  numberblanklines=false,
  inputencoding={utf8},
  belowskip=-1mm,
  escapeinside={//*}{\^^M} % Allow to set labels and the like in comments
}

% Defines a custom environment for indented shell commands
\newenvironment{displayshellcommand}{%
	\begin{quote}%
	\ttfamily%
}{%
	\end{quote}%
}
\usepackage{listings}
\usepackage{amsmath}  % For math symbols like omega
% Define Idris2 language keywords
\lstdefinelanguage{Idris}{
    morekeywords={
        module, import, data, where, if, then, else, case, of, let, in, do, 
        Type, Int, Integer, Float, Double, Char, String, Bool, True, False, 
        List, Nil, (::), (->), (=>), Nat,(:),
    },
	morecomment=[l]{--},
}

\lstnewenvironment{haskell}{
  \vspace{1em}%
  \lstset{abovecaptionskip=1em, language=Haskell}
}{
  \vspace{1em}
}


\lstnewenvironment{idris}{
  \vspace{1em}%
  \lstset{
    language=idris,
  }
}{
  \vspace{1em}
}

% Define Agda listing style  
\lstdefinelanguage{Agda}{  
  keywords={  
    data, where, let, in, module, mutual, abstract, private,  
    public, postulate, primitive, record, field, constructor,  
    forall, Set, Type, with, rewrite, using, open, import,  
    instance, hiding, renaming, to  
  },  
  sensitive=true,  
  morecomment=[l]--,  
  morestring=[b]",  
  literate=  
    {∀}{{\ensuremath{\forall}}}1  
    {→}{{\ensuremath{\rightarrow}}}1  
    {←}{{\ensuremath{\leftarrow}}}1  
    {⊤}{{\ensuremath{\top}}}1  
    {⊥}{{\ensuremath{\bot}}}1  
    {∷}{{\ensuremath{::}}}1  
    {≡}{{\ensuremath{\equiv}}}1  
    {λ}{{\ensuremath{\lambda}}}1  
    {∘}{{\ensuremath{\circ}}}1  
    {∨}{{\ensuremath{\vee}}}1  
    {∧}{{\ensuremath{\wedge}}}1  
    {⊎}{{\ensuremath{\uplus}}}1  
    {×}{{\ensuremath{\times}}}1  
    {ℕ}{{\ensuremath{\mathbb{N}}}}1  
    {ℤ}{{\ensuremath{\mathbb{Z}}}}1  
    {⊢}{{\ensuremath{\vdash}}}1  
    {∈}{{\ensuremath{\in}}}1  
    {∉}{{\ensuremath{\notin}}}1  
    {∋}{{\ensuremath{\ni}}}1  
    {∌}{{\ensuremath{\not\ni}}}1  
}  

% Define the Agda environment  
\lstnewenvironment{agda}  
{\lstset{  
    language=Agda,  
}}{}  

\title{Idris2}
\event{Seminar: Programming Languages in Winter term 2024/2025}
\author{Mehrdad Shahidi, Zahra Khodabakhishan
  \institute{Rheinland-Pfälzische Technische Universität Kaiserslautern-Landau, Department of Computer Science}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{abstract}
Idris2 is a functional programming language that leverages Quantitative Type Theory (QTT) to offer an advanced dependent type system, making it well-suited for both practical software development and formal proof verification.
This report provides example problem verification\todo{add problem name here} using Idris2 to showcase its capabilities, examines its QTT-based approach, compares its features with Agda, and concludes by summarizing key insights and suggesting directions for future exploration.

\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}
\label{sec:introduction}
As software systems become increasingly complex and critical to our daily operations, programming languages continue to evolve to meet growing demands for reliability and correctness.
Idris2 represents a significant advancement in this evolution by offering a unique approach to program correctness through its type system based on Quantitative Type Theory (QTT).
As a pure functional programming language with first-class types, Idris2 allows types to be manipulated and computed just like any other value, fundamentally shifting how we approach programming.
Unlike traditional programming languages that catch errors at runtime, Idris2 enables developers to work collaboratively with the compiler, which acts as an assistant during development, helping to prove properties about code and suggest potential solutions for incomplete programs.
This type-driven development approach ensures program correctness before execution, making it particularly valuable for critical systems, mathematical proofs, and complex state-dependent applications like concurrent systems\cite{BradyYoutube2023}.
\\example of idris2 code:
\begin{idris}
	safeDiv : (num : Nat) -> (d : Nat) -> {auto ok : GT d Z} -> Nat  
	safeDiv n d  = div n d  

	-- This works automatically because Idris can prove 0 < 5  
	example : Nat  
	example = safeDiv 12 5

	-- This code failes to compile because Idris can't prove 0 < 0
	example2 : Nat
	example2 = safeDiv 12 0


\end{idris}

The following sections provide an accessible overview of Idris2's key aspects.
We begin with a brief introduction to Quantitative Type Theory (QTT) and compare Idris2 with both Haskell and Agda, highlighting how these languages approach type systems differently.
While Haskell represents traditional functional programming and Agda focuses heavily on theorem proving, Idris2 aims to bridge the gap between practical programming and formal verification.
We then explore some distinctive features of Idris2 through simple examples, such as its interactive development environment and dependent types.
To demonstrate these concepts in action, we present a straightforward verification example that shows how Idris2's type system can prevent common programming errors.
The report concludes with a discussion of current limitations and practical considerations when using Idris2 in real-world scenarios.

\section{Background}  
\label{sec:background}  
Programming languages traditionally separate types and values, which means that certain kinds of errors, particularly those related to invalid values or incorrect data structures, are only caught at runtime. This limitation has been a significant challenge in software engineering, as it allows many types of errors—such as accessing an element from an empty list—to slip through until the program is executed. The goal of dependent types is to solve this problem by allowing types to depend on values, enabling the type system itself to enforce correctness at compile time.

The concept of dependent types is not new; it has roots in mathematical logic and type theory. However, its application in programming languages was limited for many years. Idris, first introduced by Edwin Brady in 2009, was a pioneering language that sought to make dependent types practical and usable in real-world programming. Idris was designed with the goal of enabling programmers to capture more precise specifications in the type system itself, making programs both more expressive and safer. Through its use of dependent types, Idris allowed for the formal verification of certain aspects of a program at compile time—such as proving that a vector is non-empty before calling the head function.

Despite its potential, Idris 1 had its limitations. The performance of type checking was not optimal for large programs, and the language’s implementation and theoretical foundations were not as robust as they could be. These shortcomings were particularly evident when trying to use Idris for large-scale or more complex applications. The need for improvement in both usability and performance led to the development of Idris 2.

Idris 2 represents a complete redesign of the language, drawing on the lessons learned from Idris 1. One of the key challenges in the original Idris was the efficiency of type checking, especially when dealing with large programs. Idris 2 addressed this by significantly improving its type checking performance. Furthermore, the language introduced the ability to erase compile-time arguments more effectively, reducing the overhead in generating executable code. Additionally, Idris 2 incorporated linear types through Quantitative Type Theory, providing a mechanism for better resource management and more precise control over side-effects in functional programming.

These improvements made Idris 2 a more practical and scalable tool for developers looking to leverage dependent types.
  

\section{Theorem Proving}
\label{sec:Propositions and judgments}
\subsection{Propositions and Judgments}
Before delving into theorem proving, it is essential to understand the foundational framework of constructive logic. Also known as intuitionistic logic, it differs from classical logic by rejecting the Law of Excluded Middle—which asserts that every proposition is either true or false. Instead, constructive logic considers a proposition true only if it can be explicitly proven. Thus, an unproven proposition is not necessarily false; it may simply be unprovable.

Constructive logic builds a database of judgments, where each judgment is a formally validated proof. This approach ensures the logical system’s integrity by requiring concrete evidence for every proposition. For instance, proving a number is even involves explicitly providing a number that satisfies the condition, rather than merely asserting it. By avoiding assumptions like the Law of Excluded Middle, constructive logic maintains consistency and reliability, ensuring that only provable propositions are included in the system.
\subsection{Equality}
\label{sec:Equality}
\subsubsection{definitional and propositional equality}
Equality in Idris is captured by the Equal type, defined as follows:
\begin{idris}
   data (=) : a -> b -> Type where  
   Refl : x = x
\end{idris}
This states that two values are equal if they are definitionally identical, with Reflexive serving as explicit evidence of their equality.

\begin{idris}
    plusReducesL : (n : Nat) -> plus Z n = n
    plusReducesL n = Refl
\end{idris}
This proposition asserts that adding zero to any number n results in n, which is definitionally true.
\begin{idris}
    plusReducesR : (n : Nat) -> plus n Z = n
    plusReducesR n = Refl
\end{idris}
This is not definitionally true, because the plus function is defined recursively on its first argument. While adding zero as the second argument reduces for specific cases, the reduction is not immediate or definitional. As a result, Reflexive cannot prove plusReducesR directly.

In Idris, an equality type that can be proved using Reflexive alone is known as definitional equality. For cases like plusReducesR, where Reflexive is insufficient, additional techniques, such as propositional equality or rewriting, may be required.
\subsubsection{Heterogeneous Equality}
Equality in Idris is heterogeneous, meaning that it allows for the possibility of proposing equalities between values of different types. It means suggesting that two values of different types can be considered equal under certain assumptions or relationships. It becomes essential when working with dependent types, where types themselves depend on values.
\begin{idris}
    vect_eq_length : (xs : Vect n a) -> (ys : Vect m a) ->
    (xs = ys) -> n = m 
\end{idris}
(xs = ys) asserts that the two vectors are equal in both value and type.So if xs = ys, then n and m must also be equal, because the length of the vector (n or m) is part of its type. This is why the function can safely return n = m.
\subsubsection{Substitutive Property (Leibniz Equality)}
Idris also supports reasoning about equality using the substitutive property, often referred to as Leibniz Equality.
It formalizes the idea that if two values are equal, they are indistinguishable under any property. In Idris, this can be expressed as:
\begin{idris}
leibnizEq : (a : A) -> (b : A) -> Type
leibnizEq a b = (P : A -> Type) -> P a -> P b
\end{idris}
\section{Features of Idris2}  
\label{sec:features}
\subsection{Introduction to Quantitative Type Theory (QTT)}
Quantitative Type Theory (QTT) extends traditional dependent type theory by adding explicit tracking of how variables are used in programs \cite{atkey2018syntax}. Developed by Conor McBride, it addresses inefficiencies in traditional type theory, where variables serve both as type constructors and computational entities. By explicitly modeling variable usage, QTT improves efficiency, especially in resource management like memory.
\subsection{Multiplicities}
In QTT,
each variable binding is associated with a quantity (or multiplicity) which denotes the number
of times a variable can be used in its scope: either zero, exactly once, or unrestricted \cite{atkey2018syntax}.

\begin{lstlisting}[mathescape=true]
  0: The variable is used only at compile time and erased at runtime
  1: The variable must be used exactly once at runtime (linear)
  $\omega$: The variable can be used any number of times (unrestricted)
\end{lstlisting}
\vspace{1em}  % Adds one line space

Multiplicities in Idris 2 describe how often a variable must be used within the scope of its binding. A variable is considered "used" when it appears in the body of a definition, as opposed to a type declaration, and when it is passed as an argument with multiplicity 1 or \(\omega\). The multiplicities of a function's arguments are specified by its type, and they dictate how many times the arguments can be used within the function's body. Variables with multiplicity \(\omega\) are considered unrestricted: they can be passed to argument positions with multiplicities 0, 1, or \(\omega\). On the other hand, a function that accepts an argument with multiplicity 1 guarantees that the argument will not be shared within its body in the future, although it is not required to ensure that it has not been shared in the past\cite{brady2021idris}.
\subsubsection{Lineaitiy Example} 
In Idris 2, linearity or multiplicity of 1 as we saw, is a property of values in the type system that enforces the idea that a value must be used exactly once. This concept is rooted in linear logic and ensures resources are managed precisely, preventing accidental duplication or omission. 

\vspace{1em}  % Adds one line space
We have a File System Protocol that allows us to open a file, close it and delete . The protocol enforces linearity to ensure that files are managed correctly.
The idea is to use linearity to enforce that:
\begin{itemize}
  \item[--] A file cannot be opened if it's already open.
  \item[--] A file cannot be closed if it's already closed.
  \item[--] A file cannot be deleted unless it's closed.
\end{itemize}

A file can be in one of two states: Opened or Closed:
\begin{idris} 
  
  data FileState = Opened | Closed

\end{idris}
We model the file's state in the type system:
\begin{idris}
  data File : FileState -> Type where
    MkFile : (fileName : String) -> File st

\end{idris}
the transitions between states:
\begin{idris}
  openFile : (1 f : File Closed) -> File Opened
  openFile (MkFile name) = MkFile name
  
  closeFile : (1 f : File Opened) -> File Closed
  closeFile (MkFile name) = MkFile name
  
\end{idris}
Ensure that files are created and used linearly:
newFile accepts a function that takes a Closed file, ensuring the file is used exactly once.
\begin{idris}
  newFile : (1 p : (1 f : File Closed) -> IO ()) -> IO ()
  newFile p = p (MkFile "example.txt")
    
\end{idris}
Only files in the Closed state can be deleted :
\begin{idris}
  deleteFile : (1 f : File Closed) -> IO ()
  deleteFile _ = putStrLn "File deleted."
\end{idris}
A protocol example can be seen below:
\begin{idris}
  fileProg : IO ()
  fileProg = 
      newFile $ \f => 
          let f' = openFile f
              f'' = closeFile f' in
              deleteFile f''
  
\end{idris}
This protocol demonstrates how linear types in Idris2 enforce safe resource usage by modeling state transitions, preventing runtime errors, and ensuring predictable, reliable programs.
\subsubsection{Erasure}

\subsection{Interface}
we use interfaces (similar to type classes in Haskell) to define functions or operations that can work seamlessly across different types. This capability, known as overloading, is achieved by defining a common interface (a set of operations) and then providing specific implementations for each type that becomes an instance of the interface.

\subsubsection{Implementing Show for Nat :}
the Show interface is used to convert values into String.The key rule is uniqueness of the implementation , There should be only one implementation of am interface for specific type.
\begin{idris}
    Show Nat where
    show Z     = "Zero"
    show (S Z) = "One"
    show (S (S k)) = "Two"
    show (S (S (S k))) = "S(" ++ show (S (S k)) ++ ")"
  
\end{idris}
Additionally, Implementations can have constraints. For instance, to implement Show for a vector (Vect n a), there must already be a Show implementation for the element type a.
\begin{idris}
    Show a => Show (Vect n a) where
\end{idris}
This is a constraint. It means the implementation of Show for Vect n a (a vector of n elements of type a) is only valid if the element type a itself has an instance of Show. 
\begin{idris}
    Show a => Show (Vect n a) where
    show xs = "[" ++ show' xs ++ "]" where
        show' : forall n . Vect n a -> String
        show' Nil        = ""
        show' (x :: Nil) = show x
        show' (x :: xs)  = show x ++ ", " ++ show' xs
\end{idris}
\subsubsection{Type classes in Idris vs Haskell} 
Type classes are a central feature of both Haskell and Idris 2. While they share many similarities, Idris 2's more expressive dependent type system enables additional flexibility and power.

In Idris 2, type classes leverage dependent types, allowing types to depend on values. This extends polymorphism beyond types (as in Haskell) to include relationships between types and values, enabling more expressive and precise constraints. Haskell lacks this capability due to its non-dependent type system.


\subsection{Bidirectional Type Checking}
\subsubsection{Type Checking in Idris2 vs Haskell}
Haskell uses a monotonic type checking system, primarily based on ** Hindley-Milner type inference** with extensions for generalized algebraic data types (GADTs) and type families.

Types are typically inferred using a unification algorithm, which attempts to match the types of expressions with the expected types.
The Haskell compiler (GHC) uses a form of principal type inference for non-dependent types, meaning it attempts to deduce the most general type that fits the given expression, but it doesn't differentiate between checking and synthesizing as explicitly.

However, Idris 2 uses bidirectional type checking, which separates the roles of type synthesis (deducing types) and type checking (verifying types). This is crucial for dependent types and provides more flexibility and efficiency in type inference.

\subsection{Interactive Development Environment}  
\label{subsec:ide}  
% Type-driven development workflow  
% Hole mechanism  
% Interactive editing features  

\subsection{Dependent Types in Practice}  
\label{subsec:dependent-types}  
% Real-world applications  
% Code examples  
% Common patterns and idioms  

\section{Verification Example}  
\label{sec:verification-example}  
\subsection{Problem Description}  
\label{subsec:problem-desc}  
% Detailed description of the chosen verification problem  
% Motivation and relevance  

\subsection{Implementation and Proof}  
\label{subsec:implementation}  
% Step-by-step solution  
% Code with explanations  
% Proof strategy  

\section{Practical Considerations}  
\label{sec:practical-considerations}  
\subsection{Current Limitations}  
\label{subsec:limitations}  
% Technical limitations  
% Ecosystem challenges  
% Performance considerations  

\subsection{Future Directions}  
\label{subsec:future}  
% Potential improvements  
% Research opportunities  
% Community development  

\section{Conclusion}  
\label{sec:conclusion}  
% Summary of key points  
% Final thoughts on Idris2's role in programming  
% Recommendations for adoption  

\newpage
\nocite{*}
\bibliographystyle{eptcs}
\bibliography{references}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
